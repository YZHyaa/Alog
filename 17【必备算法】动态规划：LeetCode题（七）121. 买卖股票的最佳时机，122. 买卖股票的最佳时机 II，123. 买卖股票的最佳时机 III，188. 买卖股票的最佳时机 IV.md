六道股票问题的具体思路已经在上一篇 [【必备算法】动态规划：一个思路解决六道股票问题](https://blog.csdn.net/weixin_43935927/article/details/109791453) 分析过了，下面就直接给出相应的动归代码了。
>PS：不看上一篇直接看代码可能优点困难..

## [122. 买卖股票的最佳时机 II¹](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)

给定一个数组，它的第 *i* 个元素是一支给定股票第 *i* 天的价格。

设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

**注意**：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 

**示例 1:**

```
输入: [7,1,5,3,6,4]
输出: 7
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。
```

**示例 2:**

```
输入: [1,2,3,4,5]
输出: 4
解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。
     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
```

**示例 3:**

```
输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
```

**提示：**

- `1 <= prices.length <= 3 * 10 ^ 4`
- `0 <= prices[i] <= 10 ^ 4`

```java
public int maxProfit(int[] prices) {
        int n = prices.length;
        if (n < 2) return 0;
        
        // 状态定义
        // 注：mp[i][k][j] --k无限制--> mp[i][j]，具体参考上篇关于二维状态的猜想
        int[][] mp = new int[n][2];
		
		// 初始状态
        mp[0][0] = 0; 		   // 不持股
        mp[0][1] = -prices[0]; // 买入一股  
		
		// 状态递推
        for (int i = 1; i < n; i++) {
            mp[i][0] = Math.max(mp[i - 1][0], mp[i - 1][1] + prices[i]);
            mp[i][1] = Math.max(mp[i - 1][1], mp[i - 1][0] - prices[i]);
        }
        
		// 最终状态
        return mp[n - 1][0];
    }
```
可以将上面的状态数组优化成两个状态变量，因为在上面递推的过程中，所需要的状态只有 `mp[i-1][0]` 和 `mp[i-1][1]`，从而空间复杂度可以从O(n)优化成O(1)。
```java
public int maxProfit(int[] prices) {
        int n = prices.length;
        if (n < 2) return 0;
        
        // 状态定义+初始状态
        int mp_0 = 0, mp_1 = -prices[0];
		
		// 状态递推
        for (int i = 1; i < n; i++) {
            int tmp = mp_0;
            mp_0 = Math.max(mp_0, mp_1 + prices[i]);
            mp_1 = Math.max(mp_1, tmp - prices[i]);
        }
		
		// 最终状态
        return mp_0;
    }
```
## [121. 买卖股票的最佳时机¹](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

给定一个数组，它的第 *i* 个元素是一支给定股票第 *i* 天的价格。

如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。

注意：你不能在买入股票前卖出股票。

**示例 1:**

```
输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
```

**示例 2:**

```
输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
```


```java
 public int maxProfit(int[] prices) {
        int n = prices.length;
        if (n < 2) return 0;
        
        // 状态定义
        int[][] mp = new int[n][2];
		
		// 初始状态
        mp[0][0] = 0; 
        mp[0][1] = -prices[0];
		
		// 状态递推
        for (int i = 1; i < n; i++) {
            mp[i][0] = Math.max(mp[i - 1][0], mp[i - 1][1] + prices[i]);
            mp[i][1] = Math.max(mp[i - 1][1], - prices[i]); // 上题交易无数次是 mp[i-1][0] - prices[i]
        }
        
		// 最终状态
        return mp[n - 1][0];
    }
```
同理，本题也可以对状态进行优化，使空间复杂度优化成O(1)
```java
 public int maxProfit(int[] prices) {
        int n = prices.length;
        if (n < 2) return 0;

        // 状态定义+初始状态
        int mp_0 = 0, mp_1 = -prices[0];
		
		// 状态递推
        for (int i = 0; i < n; i++) {
            int tmp = mp_0;
            mp_0 = Math.max(mp_0, mp_1 + prices[i]);
            mp_1 = Math.max(mp_1, - prices[i]);
        }
		
		// 最终状态
        return mp_0;
    }
```



## [123. 买卖股票的最佳时机 III³](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/)

给定一个数组，它的第 *i* 个元素是一支给定的股票在第 *i* 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 *两笔* 交易。

**注意:** 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**示例 1:**

```
输入: [3,3,5,0,0,3,1,4]
输出: 6
解释: 在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。
     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。
```

**示例 2:**

```
输入: [1,2,3,4,5]
输出: 4
解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。   
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。   
     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
```

**示例 3:**

```
输入: [7,6,4,3,1] 
输出: 0 
解释: 在这个情况下, 没有交易完成, 所以最大利润为 0。
```
```java
public int maxProfit(int[] prices) {
        int n = prices.length;
        if (n < 2) return 0;
		
		// 状态定义
		// 注：3是交易次数，虽然题上要求是2次，但还要考虑不交易的情况。即可以交易0,1，2次。
		// 再强调一次，这里说的交易是完成一买一卖，所以交易次数也可以理解成卖出次数
        int[][][] mp = new int[n][3][2];
		
		// 初始状态
		// 这里我们要初始的是第一天mp[0][][]的全部情况（6种=2*3）
        mp[0][0][0] = 0;          // 第一天不做操作
        mp[0][0][1] = -prices[0]; // 第一天买入股票
        mp[0][1][0] = 0;		  // 第一天一买一卖，相当于没操作
        mp[0][1][1] = -prices[0]; // 第一天一买一卖后再买入
        mp[0][2][0] = 0;		  // 第一天一买一卖两次，实际上操作了个寂寞
        mp[0][2][1] = Integer.MIN_VALUE;   // 买卖两次已经到达上限了，即使他还持有股票也卖不了（这种情况实际不允许存在，所以不写其实也行,但为了完整就写上了）
		
		// 状态递推
		// 注：三维状态照理说要三重循环，但是k、j一共就只有6种排列组合，所以直接枚举出来了
        for (int i = 1; i < n; i++) {
            mp[i][0][0] = mp[i-1][0][0]; // 永远是0，其实没必要递推（提交时可以注释掉）
            mp[i][0][1] = Math.max(mp[i-1][0][1], mp[i-1][0][0] - prices[i]);

            mp[i][1][0] = Math.max(mp[i-1][1][0], mp[i-1][0][1] + prices[i]);
            mp[i][1][1] = Math.max(mp[i-1][1][1], mp[i-1][1][0] - prices[i]);

            mp[i][2][0] = Math.max(mp[i-1][2][0], mp[i-1][1][1] + prices[i]);
            mp[i][2][1] = Integer.MIN_VALUE; // 没实际意义，没必要递推（提交时可以注释掉）
        }
		
		// 最终状态
        return mp[n-1][2][0];
    }
```
## [188. 买卖股票的最佳时机 IV³](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/)

给定一个数组，它的第 *i* 个元素是一支给定的股票在第 *i* 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 **k** 笔交易。

**注意:** 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**示例 1:**

```
输入: [2,4,1], k = 2
输出: 2
解释: 在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。
```

**示例 2:**

```
输入: [3,2,6,5,0,3], k = 2
输出: 7
解释: 在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。
     随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。
```

这种是最通用的情况，对于每一天需要使用不同的 k 值更新所有的最大收益，对应持有 0 份股票或 1 份股票。如果 k 超过一个临界值，最大收益就不再取决于允许的最大交易次数，而是取决于股票价格数组的长度，因此可以进行优化。那么这个临界值是什么呢？

一个有收益的交易至少需要两天（在前一天买入，在后一天卖出，前提是买入价格低于卖出价格）。如果股票价格数组的长度为 n，则有收益的交易的数量最多为 n / 2（整数除法）。因此 k 的临界值是 n / 2。如果给定的 k 不小于临界值，即 k >= n / 2，则可以将 k 扩展为正无穷，此时问题等价于情况二。

```java
class Solution {
	
	// 将上面123题代码改造一下
    public int maxProfit(int k, int[] prices) {
        int n = prices.length;
        if (n < 2) return 0;
		
		// 如果k>=n/2那就相当于是k无限制
        if (k >= n/2) {
            return maxProfit(prices);
        }
		
		// 状态定义
		// 注：k+1是因为还要把0算进来
        int[][][] mp = new int[n][k+1][2];
		
		// 初始状态
		// 同上一题，都是初始第一天（i=0）
        for (int kk = 0; kk < k; kk++) {
            mp[0][kk][0] = 0; 		   // 不买
            mp[0][kk][1] = -prices[0]; // 买
        }
		
		// 状态递推
        for (int i = 1; i < n; i++) {
            for (int kk = 0; kk <= k; kk++) {
            	// 注：由于mp[kk-1]可能出现[0-1]的情况，所以要先判断
                mp[i][kk][0] = kk > 0 ? Math.max(mp[i-1][kk][0], mp[i-1][kk-1][1] + prices[i]) : mp[i-1][kk][0];
                mp[i][kk][1] = Math.max(mp[i-1][kk][1], mp[i-1][kk][0] - prices[i]);
            }
        }
		
		// 最终状态
        return mp[n-1][k][0];
    }
	
	// 上面122题的代码 
    public int maxProfit(int[] prices) {
        int n = prices.length;
        if (n < 2) return 0;
        
        int mp_0 = 0, mp_1 = -prices[0];
		
        for (int i = 0; i < n; i++) {
            int tmp = mp_0;
            mp_0 = Math.max(mp_0, mp_1 + prices[i]);
            mp_1 = Math.max(mp_1, tmp - prices[i]);
        }
		
        return mp_0;
    }

}
```
再放个[参考链接](https://leetcode-cn.com/circle/article/qiAgHn/)..，他里面是k的定义是买入股票次数

剩下两个股票问题请看下一篇：[【必备算法】动态规划：LeetCode（八）309. 最佳买卖股票时机含冷冻期，714. 买卖股票的最佳含手续费](https://blog.csdn.net/weixin_43935927/article/details/109793337)..

